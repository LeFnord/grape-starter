#!/usr/bin/env ruby
# frozen_string_literal: true
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))


require 'pry'
require 'gli'
require 'starter'

include GLI::App

program_desc 'Create initial grape api skeleton'

version Starter::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'overwrites existend stuff'
switch [:f, :force], negatable: false

desc 'Creates initial api skeleton'
arg_name 'awesome_api'
command :new do |c|
  c.flag [:p, :prefix],
         default_value: 'api',
         desc: 'sets the prefix of the API (default: api, given: takes this)'

  c.action do |global_options, options, args|
    dest = args.empty? ? nil : File.join(Dir.getwd, args.first)

    case
    when args.empty? || dest.nil?
      exit_now! 'no name given: grape-starter new project'
    when Dir.exist?(dest) && !global_options[:force]
      exit_now! 'project exist: -f to overwrite'
    else
      starter_gem = Gem::Specification.find_by_name('grape-starter').gem_dir
      src = File.join(starter_gem, 'template', '.')

      Starter::Builder.new!(args.first, src, dest, options[:p])
      $stdout.puts "created: #{args.first}"

      # after creating tasks
      FileUtils.cd(dest) do
        $stdout.puts `bundle install`
        $stdout.puts `bundle exec rubocop -a`
        $stdout.puts `git init`
      end
    end
  end
end

desc 'Adds given new resource'
long_desc "Adds given resource, hereby the numerus of the provided
resource would be respected to create singular or plural endpoints"
arg_name 'resource [post* get* put* patch* delete*]'
command :add do |c|
  c.desc 'adds entity file'
  c.switch [:e, :entity], negatable: false

  c.action do |global_options, options, args|
    exit_now! 'no resource given' if args.empty?

    resource = args.shift
    set = args

    begin
      builder_options = global_options.merge(set: set).merge(options)
      created_files = Starter::Builder.add!(resource, builder_options)

      `bundle exec rubocop -a #{created_files.join(' ')}`
      $stdout.puts "added resource: #{resource}"
    rescue => e
      exit_now! e
    end
  end
end

desc 'Removes given resource'
arg_name 'resource'
command :rm do |c|
  c.desc 'removes also entity file'
  c.switch [:e, :entity], negatable: false

  c.action do |global_options, options, args|
    exit_now! 'no resource given' if args.empty?
    resource = args.first

    Starter::Builder.remove!(resource, options)

    $stdout.puts "removed resource: #{resource}"
  end
end


pre do |_global, _command, _options, _args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |_exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
